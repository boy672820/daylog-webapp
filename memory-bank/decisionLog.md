# 의사 결정 로그

이 문서는 프로젝트 진행 과정에서 내려진 주요 결정사항들을 기록합니다.

## 결정 기록 형식
각 결정은 다음 형식으로 기록됩니다:

```
## [날짜] 결정 제목

### 상황
결정이 필요했던 상황과 배경 설명

### 고려한 대안
1. 대안 1: 설명
2. 대안 2: 설명
3. 대안 3: 설명

### 결정
선택한 대안과 그 이유

### 영향
이 결정이 프로젝트에 미치는 영향

### 후속 조치
결정에 따른 후속 작업 항목
```

---

## [2025-03-15] 메모리 뱅크 초기화

### 상황
프로젝트의 체계적인 관리와 문서화를 위해 메모리 뱅크 시스템을 도입하기로 결정했습니다.

### 고려한 대안
1. 기존 문서 시스템 유지: 단순하지만 체계적인 관리가 어려움
2. 외부 문서 관리 도구 사용: 추가 도구 학습 필요
3. 메모리 뱅크 시스템 도입: 프로젝트 내에서 일관된 문서화 가능

### 결정
메모리 뱅크 시스템을 도입하여 프로젝트 문서화를 체계적으로 관리하기로 결정했습니다.

### 영향
- 프로젝트 문서화가 체계적으로 이루어짐
- 의사 결정 과정이 명확하게 기록됨
- 팀원 간 정보 공유가 용이해짐

### 후속 조치
- 메모리 뱅크 핵심 파일 생성
- 기존 문서 내용을 메모리 뱅크 형식으로 마이그레이션
- 팀원들에게 메모리 뱅크 사용법 공유

---

## [2025-03-16] 이벤트 기반 아키텍처 채택

### 상황
일일 회고 작성 후 주간 요약을 자동으로 생성하는 시스템을 설계해야 했습니다. 이 과정에서 시스템 컴포넌트 간의 결합도를 낮추고 확장성을 높이는 아키텍처가 필요했습니다.

### 고려한 대안
1. 동기식 API 호출: 단순하지만 결합도가 높고 장애 전파 위험
2. 배치 처리 방식: 주기적 실행으로 실시간성 부족
3. 이벤트 기반 아키텍처: 느슨한 결합과 확장성 제공

### 결정
AWS EventBridge, DynamoDB Stream, Lambda를 활용한 이벤트 기반 아키텍처를 채택했습니다.

### 영향
- 시스템 컴포넌트 간 느슨한 결합 구현
- 비동기 처리를 통한 확장성 확보
- 장애 격리 및 복원력 향상
- 이벤트 기반 워크플로우 구현 용이

### 후속 조치
- DynamoDB Stream 활성화
- EventBridge 이벤트 버스 및 규칙 설정
- Lambda 함수 구현 (dynamoDBStreamDaily, dailyConsumer)
- 이벤트 처리 로직 구현

---

## [2025-03-16] Next.js App Router 및 서버 컴포넌트 채택

### 상황
프론트엔드 아키텍처를 설계하면서 성능, SEO, 개발 경험을 모두 고려한 프레임워크 선택이 필요했습니다.

### 고려한 대안
1. React SPA: 클라이언트 측 렌더링으로 초기 로딩 성능 및 SEO 이슈
2. Next.js Pages Router: 기존 방식이지만 서버 컴포넌트 미지원
3. Next.js App Router: 서버 컴포넌트 지원 및 하이브리드 렌더링 가능

### 결정
Next.js App Router와 서버 컴포넌트를 채택하여 하이브리드 렌더링 아키텍처를 구현했습니다.

### 영향
- 서버 측 렌더링을 통한 초기 로딩 성능 향상
- 클라이언트 번들 크기 감소
- SEO 최적화
- 서버와 클라이언트 컴포넌트의 명확한 분리

### 후속 조치
- 서버 컴포넌트와 클라이언트 컴포넌트 분리
- 데이터 페칭 로직 서버 컴포넌트로 이동
- 인터랙티브 UI 요소는 클라이언트 컴포넌트로 구현

---

## [2025-03-16] Tiptap 기반 리치 텍스트 에디터 채택

### 상황
사용자가 회고를 작성할 때 다양한 서식과 미디어를 지원하는 리치 텍스트 에디터가 필요했습니다.

### 고려한 대안
1. 기본 textarea: 단순하지만 서식 지원 불가
2. Draft.js: React 기반이지만 유지보수 이슈
3. Quill: 인기 있는 에디터지만 확장성 제한
4. Tiptap: ProseMirror 기반의 확장 가능한 에디터

### 결정
Tiptap 라이브러리를 기반으로 확장 가능한 리치 텍스트 에디터를 구현했습니다.

### 영향
- 사용자 친화적인 편집 경험 제공
- 다양한 서식 및 미디어 지원
- 확장 가능한 아키텍처로 기능 추가 용이
- HTML 출력을 Markdown으로 변환하여 AI 처리 최적화

### 후속 조치
- 기본 에디터 컴포넌트 구현
- 필요한 확장 기능 추가 (이미지, 색상, 정렬 등)
- 플로팅 메뉴 및 툴바 UI 구현
- 자동 저장 기능 구현

---

## [2025-03-16] DailySummarizedRule Lambda 함수 추가

### 상황
DailySummarizedRule 규칙이 EventBridge에 정의되어 있었지만, 이벤트를 처리할 Lambda 함수가 연결되어 있지 않았습니다. 이벤트를 로깅하고 처리하기 위한 Lambda 함수가 필요했습니다.

### 고려한 대안
1. 기존 dailyConsumer Lambda 함수 확장: 기존 함수에 추가 로직을 구현하는 방식
2. 새로운 Lambda 함수 생성: 이벤트 타입별로 별도의 함수를 구현하는 방식
3. 외부 서비스로 이벤트 전달: 이벤트를 외부 서비스로 전달하여 처리하는 방식

### 결정
이벤트 타입별로 책임을 분리하기 위해 새로운 Lambda 함수(daily-summarized)를 생성하여 DailySummarized 이벤트를 처리하도록 구현했습니다.

### 영향
- 이벤트 타입별 처리 로직 분리로 코드 유지보수성 향상
- 각 이벤트 처리에 대한 독립적인 모니터링 및 로깅 가능
- 이벤트 처리 실패 시 다른 이벤트 처리에 영향 최소화

### 후속 조치
- 로깅 외에 추가적인 처리 로직 구현 필요
- 이벤트 처리 결과에 따른 알림 시스템 구현 고려
- 이벤트 처리 성능 모니터링 설정

---

## [2025-03-16] AWS Amplify Gen2 채택

### 상황
백엔드 인프라를 효율적으로 관리하고 프론트엔드와 통합하기 위한 솔루션이 필요했습니다.

### 고려한 대안
1. 수동 AWS 리소스 관리: 완전한 제어 가능하지만 복잡성 증가
2. AWS CDK: 코드형 인프라지만 통합 솔루션 부재
3. AWS Amplify Gen1: 통합 솔루션이지만 유연성 제한
4. AWS Amplify Gen2: TypeScript 기반 IaC와 통합 솔루션 제공

### 결정
AWS Amplify Gen2를 채택하여 TypeScript 기반의 인프라 정의와 프론트엔드 통합을 구현했습니다.

### 영향
- 코드형 인프라(IaC) 구현으로 버전 관리 가능
- 프론트엔드와 백엔드의 원활한 통합
- 개발 환경과 프로덕션 환경의 일관성 확보
- AWS 서비스 활용 용이성 증가

### 후속 조치
- 백엔드 리소스 정의 (auth, data, functions)
- 데이터 모델 및 권한 설정
- Lambda 함수 구현
- 프론트엔드 통합 (generateClient, AuthGetCurrentUserServer)

---

## [2025-03-19] summary-weekly-reflection Lambda 함수 구현

### 상황
주간 회고 요약을 생성하기 위한 Lambda 함수가 필요했습니다. SQS를 통해 EventBridge 이벤트를 수신하고, 해당 이벤트에 포함된 summaryId와 userId를 기반으로 SummaryContent 테이블의 데이터를 조회하여 AI 요약을 생성해야 했습니다.

### 고려한 대안
1. 단일 함수 구현: 모든 로직을 하나의 함수에 구현하는 방식
2. 서비스 계층 분리: 데이터 접근, 이벤트 처리, AI 요약 생성 등의 책임을 분리하는 방식
3. 외부 API 호출 방식: 요약 생성을 외부 서비스에 위임하는 방식

### 결정
데이터 접근 로직을 캡슐화하는 AmplifyDataClientAdapter 클래스를 구현하고, 이를 통해 SummaryContent 테이블에 접근하는 방식을 선택했습니다. 이벤트 처리와 AI 요약 생성 로직은 함수 내에서 직접 구현하되, 향후 확장성을 고려하여 모듈화된 구조로 설계했습니다.

### 영향
- 데이터 접근 로직의 캡슐화로 코드 재사용성 및 테스트 용이성 향상
- 인터페이스 기반 설계로 향후 구현 변경 시 유연성 확보
- AI 요약 생성 로직을 위한 확장 가능한 구조 마련
- 비동기 처리를 통한 효율적인 이벤트 처리

### 후속 조치
- OpenAI API를 활용한 실제 AI 요약 생성 로직 구현
- 에러 처리 및 재시도 메커니즘 강화
- 요약 결과에 대한 알림 시스템 구현 고려
- 성능 모니터링 및 최적화

---

## [2025-03-19] SQS 중복 처리 방지 기능 추가

### 상황
SQS의 at-least-once 전송 특성으로 인해 동일한 메시지가 여러 번 처리될 수 있는 문제가 발생할 수 있었습니다. 이로 인해 동일한 주간 회고에 대해 AI 요약이 여러 번 생성되고 업데이트될 가능성이 있었습니다.

### 고려한 대안
1. SQS 메시지 ID 기반 중복 제거: 처리된 메시지 ID를 별도 저장소에 기록하는 방식
2. DynamoDB 조건부 업데이트: 업데이트 시 조건을 추가하여 중복 처리 방지
3. 기존 데이터 확인 방식: 처리 전 이미 요약이 존재하는지 확인하는 방식

### 결정
기존 데이터 확인 방식을 채택하여, 처리 전에 Summary 테이블에서 해당 항목을 조회하고 review 필드가 이미 존재하는 경우 처리를 건너뛰도록 구현했습니다.

### 영향
- 불필요한 AI 요약 생성 및 DynamoDB 업데이트 방지
- API 호출 비용 절감
- 일관된 데이터 유지
- 시스템 안정성 향상

### 후속 조치
- 중복 처리 방지 로직에 대한 모니터링 추가
- 다른 Lambda 함수에도 유사한 중복 처리 방지 패턴 적용 고려
- 장기적으로는 멱등성을 보장하는 아키텍처로 개선 검토